<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>文章配置使用demo</title>
      <link href="/post/e7f6b3eb.html"/>
      <url>/post/e7f6b3eb.html</url>
      
        <content type="html"><![CDATA[<p>这个是一个模板</p><span id="more"></span><table><thead><tr><th align="left">key</th><th align="center">内容</th></tr></thead><tbody><tr><td align="left">title</td><td align="center">【必需】文章标题</td></tr><tr><td align="left">date</td><td align="center">【必需】文章创建日期</td></tr><tr><td align="left">updated</td><td align="center">【可选】文章更新日期</td></tr><tr><td align="left">tags</td><td align="center">【可选】文章标籤</td></tr><tr><td align="left">categories</td><td align="center">【可选】文章分类</td></tr><tr><td align="left">keywords</td><td align="center">【可选】文章关键字</td></tr><tr><td align="left">description</td><td align="center">【可选】文章描述</td></tr><tr><td align="left">top_img</td><td align="center">【可选】文章顶部图片</td></tr><tr><td align="left">cover</td><td align="center">【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false&#x2F;图片地址&#x2F;留空)</td></tr><tr><td align="left">comments</td><td align="center">【可选】显示文章评论模块(默认 true)</td></tr><tr><td align="left">toc</td><td align="center">【可选】显示文章TOC(默认为设置中toc的enable配置)</td></tr><tr><td align="left">toc_number</td><td align="center">【可选】显示toc_number(默认为设置中toc的number配置)</td></tr><tr><td align="left">toc_style_simple</td><td align="center">【可选】显示 toc 简洁模式</td></tr><tr><td align="left">copyright</td><td align="center">【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)</td></tr><tr><td align="left">copyright_author</td><td align="center">【可选】文章版权模块的文章作者</td></tr><tr><td align="left">copyright_author_href</td><td align="center">【可选】文章版权模块的文章作者链接</td></tr><tr><td align="left">copyright_url</td><td align="center">【可选】文章版权模块的文章连结链接</td></tr><tr><td align="left">copyright_info</td><td align="center">【可选】文章版权模块的版权声明文字</td></tr><tr><td align="left">mathjax</td><td align="center">【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td></tr><tr><td align="left">katex</td><td align="center">【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认</td></tr><tr><td align="left">aplayer</td><td align="center">【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</td></tr><tr><td align="left">highlight_shrink</td><td align="center">【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中highlight_shrink的配置)</td></tr><tr><td align="left">aside</td><td align="center">【可选】显示侧边栏 (默认 true)</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack</title>
      <link href="/post/b9f20a20.html"/>
      <url>/post/b9f20a20.html</url>
      
        <content type="html"><![CDATA[<p>webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容。</p><span id="more"></span><h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><p>[toc]</p><h2 id="1、webpack-是什么？"><a href="#1、webpack-是什么？" class="headerlink" title="1、webpack 是什么？"></a>1、webpack 是什么？</h2><ul><li>官⽅方⽹网站:<a href="https://webpack.js.org/">https://webpack.js.org/</a></li><li>中⽂文⽹网站:<a href="https://www.webpackjs.com/">https://www.webpackjs.com/</a></li></ul><p><img src="/Users/zhangyuxuan/Downloads/2021-01-08-webpack-02/%E8%AF%BE%E4%BB%B6/assets/webpack_description_2-8906168.jpg" alt="image-20191014165344746"></p><p>本质上，<code>webpack</code> 是一个现代 <code>JavaScript</code> 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p><h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><p><code>webpack</code> 是一个使用 <code>Node.js</code> 实现的一个模块化代码打包工具。所以，我们需要先安装 webpack，安装之前需要搭建好 <code>Node.js</code> 环境</p><pre><code class="shell"> npm install -D webpack webpack-cli</code></pre><blockquote><p>注：不推荐全局安装</p></blockquote><p><code>webpack-cli</code> : 提供 webpack 命令、工具，类似 <code>create-react-app</code></p><p><code>webpack</code> : webpack 代码，类似 <code>react</code></p><h2 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h2><pre><code class="bash">./node_modules/.bin/webpack// 查看版本./node_modules/.bin/webpack -v</code></pre><p>也可以编辑 <code>package.json</code> 的 <code>scripts</code> 来简化输入</p><pre><code class="json">// package.json&#123;    ...,    &quot;scripts&quot;: &#123;        &quot;start&quot;: &quot;webpack&quot;// scripts 中可以定位到 ./node_modules/.bin/ 目录下    &#125;&#125;</code></pre><blockquote><p><code>scripts</code> 中使用 <code>test</code>、<code>start</code>、<code>restart</code>、<code>stop</code> 命名的时候，可以在调用的时候省略 <code>run</code>，即直接 <code>npm start</code></p></blockquote><p>当然，还可以使用更加方便的方式：</p><pre><code class="bash">npx webpack</code></pre><p>通过 <code>npx</code> 也可以帮助我们定位命令到 <code>./node_modules/.bin/</code> 目录下</p><blockquote><p>注：npm5.2+ 增加，如果没有，可以使用 npm i -g npx 来安装</p></blockquote><h2 id="4、打包模块"><a href="#4、打包模块" class="headerlink" title="4、打包模块"></a>4、打包模块</h2><p>打包之前，我们需要了解一个概念，入口文件</p><h3 id="4-1、入口文件"><a href="#4-1、入口文件" class="headerlink" title="4 - 1、入口文件"></a>4 - 1、入口文件</h3><p>入口文件就是我们项目中加载的第一个文件，比如上面的 <code>main.js</code> 文件，其它文件都是通过 <code>import</code> 等方式引入的，<code>webpack</code> 会从我们指定的入口文件开始分析所有需要依赖的文件，然后把打包成一个完整文件。</p><h3 id="4-2、打包命令"><a href="#4-2、打包命令" class="headerlink" title="4 - 2、打包命令"></a>4 - 2、打包命令</h3><pre><code class="bash">webpack ./js/index.js</code></pre><p>上面命令会使用 <code>webpack</code> 默认的一些配置对模块文件进行打包，并把打包后的文件输出到默认创建的 <code>./dist</code> 目录下，打包后的文件名称默认为 <code>main.js</code>。</p><p>模块文件打包以后，就可以在不支持 es6 模块语法的浏览器环境下引入使用了。</p><p><strong>打包文件分析</strong></p><ul><li>把分散的模块文件打包到一个文件中，不需要外部引入了</li><li>内置了一个小型模块加载器(类似 <code>requireJS</code>)，实现了打包后的代码隔离与引用</li></ul><p>以上就是 webpack 最基础的使用于基本原理，当然强大的 <code>webpack</code> 远远不止这些功能。</p><h2 id="5、打包配置"><a href="#5、打包配置" class="headerlink" title="5、打包配置"></a>5、打包配置</h2><p>虽然，我们可以直接通过命令的来打包，但是推荐创建一个 <code>webpack.config.js</code> 的配置文件来实现更方便和强大的功能。</p><p><code>webpack</code> 命令在运行的时候，默认会读取运行命令所在的目录下的 <code>webpack.config.js</code> 文件，通常我们会在项目的根目录下运行命令和创建配置文件。</p><p>我们也可以通过 <code>—config</code> 选项来指定配置文件路径：</p><pre><code class="shell">webpack --config ./configs/my_webpack.config.js</code></pre><p>通常情况下，我们的项目目录大致如下：</p><pre><code class="txt">/-- /dist - 项目打包后存放目录-- /node_modules - 第三方模块-- /src------ css/------ images/------ js/------ index.js-- webpack.config.js-- package.json</code></pre><p>配置文件</p><pre><code class="javascript">module.exports = &#123;  ...//配置项&#125;</code></pre><h3 id="5-1、mode"><a href="#5-1、mode" class="headerlink" title="5 - 1、mode"></a>5 - 1、mode</h3><p>模式 : <code>&quot;production&quot; | &quot;development&quot; | &quot;none&quot;</code></p><p>不同的模式会对 <code>webpack</code> 打包的时候进行一些对应的优化配置。</p><pre><code class="bash">module.exports = &#123;  mode: &#39;production&#39;&#125;</code></pre><h3 id="5-2、entry"><a href="#5-2、entry" class="headerlink" title="5 - 2、entry"></a>5 - 2、entry</h3><p>指定打包⼊口⽂文件，有三种不同的形式：<code>string | object | array</code></p><!--一对一：一个入口、一个打包文件--><pre><code class="js">module.exports = &#123;  entry: &#39;./src/index.js&#39;&#125;</code></pre><!--多对一：多个入口、一个打包文件--><pre><code class="js">module.exports = &#123;  entry: [    &#39;./src/index1.js&#39;,    &#39;./src/index2.js&#39;,  ]&#125;</code></pre><!--多对多：多个入口、多打包文件--><pre><code class="js">module.exports = &#123;  entry: &#123;    &#39;index1&#39;: &quot;./src/index1.js&quot;,    &#39;index2&#39;: &quot;./src/index2.js&quot;  &#125;&#125;</code></pre><h3 id="5-3、output"><a href="#5-3、output" class="headerlink" title="5 - 3、output"></a>5 - 3、output</h3><p>打包后的文件位置</p><pre><code class="js">module.exports = &#123;  ...,  output: &#123;      path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;bundle.js&quot;,        filename: &quot;[name].js&quot;    &#125;&#125;</code></pre><ul><li>可以指定一个固定的文件名称，如果是多入口多出口(<code>entry</code> 为对象)，则不能使用单文件出口，需要使用下面的方式</li><li>通过 <code>webpack</code> 内置的变量占位符：<code>[name]</code></li><li><a href="https://webpack.docschina.org/configuration/output/#template-strings">https://webpack.docschina.org/configuration/output/#template-strings</a></li></ul><h2 id="6、深入"><a href="#6、深入" class="headerlink" title="6、深入"></a>6、深入</h2><p>在 <code>webpack</code> 中，有一个很重要的特性：模块不仅仅只是 <code>js</code> 的文件，<code>webpack</code> 可以把任意文件数据作为模块进行处理，包括：非 js 文本、css、图片等等</p><pre><code class="javascript">import txt from &#39;./a.txt&#39;;console.log(txt);</code></pre><p>但是 <code>webpack</code> 默认情况下只能处理 <code>js</code> 模块，如果需要处理其它类型的模块，则需要使用它提供的一些其它功能</p><h3 id="6-1、执行简要流程"><a href="#6-1、执行简要流程" class="headerlink" title="6 - 1、执行简要流程"></a>6 - 1、执行简要流程</h3><p><img src="/Users/zhangyuxuan/Downloads/2021-01-08-webpack-02/%E8%AF%BE%E4%BB%B6/assets/workflow.png" alt="workflow"></p><ul><li><code>loaders</code>：<code>webpack</code> 中灰常核心的内容之一，前面我们说的非 js 类型的模块处理就靠它了。webpack 可以使用 loader 来预处理文件。这允许你打包除 JavaScript 之外的任何静态资源。你可以使用 Node.js 来很简单地编写自己的 loader。</li><li><code>plugins</code>：<code>webpack</code> 中另外一个核心的内容，它主要是扩展 <code>webpack</code> 本身的一些功能。插件可以运行在 <code>webpack</code> 的不同阶段（钩子 &#x2F; 生命周期）。</li></ul><h2 id="7、Loaders"><a href="#7、Loaders" class="headerlink" title="7、Loaders"></a>7、Loaders</h2><p><a href="https://webpack.js.org/loaders/">https://webpack.js.org/loaders/</a></p><pre><code class="js">module.exports = &#123;  ...,  module: &#123;      rules:[          &#123;              test:/\.xxx$/,           use:&#123;            loader: &#39;xxx-load&#39;          &#125;            &#125;      ]    &#125;&#125;</code></pre><p>当 <code>webpack</code> 碰到不识别的模块的时候，<code>webpack</code> 会在配置的 <code>module</code> 中进行该文件解析规则的查找</p><ul><li><code>rules</code> 就是我们为不同类型的文件定义的解析规则对应的 loader，它是一个数组</li><li>每一种类型规则通过 test 选项来定义，通过正则进行匹配，通常我们会通过正则的方式来匹配文件后缀类型</li><li><code>use</code> 针对匹配到文件类型，调用对应的 <code>loader</code> 进行处理</li></ul><h3 id="7-1、raw-loader"><a href="#7-1、raw-loader" class="headerlink" title="7 - 1、raw-loader"></a>7 - 1、raw-loader</h3><p>在 webpack 中通过 import 方式导入文件内容，loader 并不是 webpack 内置的，所以首先要安装</p><pre><code class="bash">npm install --save-dev raw-loader</code></pre><p>然后在 webpack.config.js 中进行配置</p><pre><code class="javascript">module.exports = &#123;  ...,  module: &#123;      rules: [      &#123;        test: /\.(txt|md)$/,        use: &#39;raw-loader&#39;        &#125;    ]    &#125;&#125;</code></pre><h3 id="7-2、file-loader"><a href="#7-2、file-loader" class="headerlink" title="7 - 2、file-loader"></a>7 - 2、file-loader</h3><p>把识别出的资源模块，移动到指定的输出⽬目录，并且返回这个资源在输出目录的地址(字符串)</p><pre><code class="bash">npm install --save-dev file-loader</code></pre><pre><code class="javascript">rules: [  ...,    &#123;        test: /\.(png|jpe?g|gif)$/,    use: &#123;      loader: &quot;file-loader&quot;,      options: &#123;        // placeholder 占位符 [name] 源资源模块的名称        // [ext] 源资源模块的后缀        name: &quot;[name]_[hash].[ext]&quot;,        //打包后的存放位置        outputPath: &quot;./images&quot;,        // 打包后文件的 url        publicPath: &#39;./images&#39;,      &#125;    &#125;    &#125;]</code></pre><blockquote><p>占位符：<a href="https://webpack.js.org/loaders/file-loader#placeholders">https://webpack.js.org/loaders/file-loader#placeholders</a></p></blockquote><h3 id="7-3、css-loader"><a href="#7-3、css-loader" class="headerlink" title="7 - 3、css-loader"></a>7 - 3、css-loader</h3><p>分析 <code>css</code> 模块之间的关系，并合成⼀个 <code>css</code></p><pre><code class="bash">npm install --save-dev css-loader</code></pre><pre><code class="js">rules: [  ...,    &#123;        test: /\.css$/,    use: &#123;      loader: &quot;css-loader&quot;,      options: &#123;              // 启用/禁用 url() 处理              url: true,              // 启用/禁用 @import 处理              import: true,        // 启用/禁用 Sourcemap        sourceMap: false      &#125;    &#125;    &#125;]</code></pre><h3 id="7-4、style-loader"><a href="#7-4、style-loader" class="headerlink" title="7 - 4、style-loader"></a>7 - 4、style-loader</h3><p>把 <code>css-loader</code> 生成的内容，用 <code>style</code> 标签挂载到⻚面的 <code>head</code> 中</p><pre><code class="bash">npm install --save-dev style-loader</code></pre><pre><code class="js">rules: [  ...,    &#123;        test: /\.css$/,    use: [&quot;style-loader&quot;, &quot;css-loader&quot;]    &#125;]</code></pre><p>同一个任务的 <code>loader</code> 可以同时挂载多个，处理顺序为：从右到左，也就是先通过 <code>css-loader</code> 处理，然后把处理后的 <code>css</code> 字符串交给 <code>style-loader</code> 进行处理</p><pre><code class="js">rules: [  ...,    &#123;        test: /\.css$/,    use: [          &#123;              loader: &#39;style-loader&#39;,              options: &#123;&#125;          &#125;,      &#39;css-loader&#39;        ]    &#125;]</code></pre><h2 id="8、Plugins"><a href="#8、Plugins" class="headerlink" title="8、Plugins"></a>8、Plugins</h2><p>扩展 <code>webpack</code> 本身的一些功能，它们会运行在 <code>webpack</code> 的不同阶段（钩子 &#x2F; 生命周期）。webpack 自身也是构建于你在 webpack 配置中用到的<strong>相同的插件系统</strong>之上！</p><p>插件目的在于解决 <a href="https://webpack.docschina.org/concepts/loaders">loader</a> 无法实现的<strong>其他事</strong>。</p><h3 id="8-1、HtmlWebpackPlugin"><a href="#8-1、HtmlWebpackPlugin" class="headerlink" title="8 - 1、HtmlWebpackPlugin"></a>8 - 1、HtmlWebpackPlugin</h3><p>在打包结束后，⾃动生成⼀个 <code>html</code> ⽂文件，并把打包生成的 js 模块引⼊到该 <code>html</code> 中</p><pre><code class="bash">npm install --save-dev html-webpack-plugin</code></pre><pre><code class="js">// webpack.config.jsconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);module.exports = &#123;    ...  plugins: [     new HtmlWebpackPlugin(&#123;       title: &quot;My App&quot;,       filename: &quot;app.html&quot;,       template: &quot;./src/html/index.html&quot;     &#125;)   ]&#125;;</code></pre><pre><code class="html">&lt;!--./src/html/index.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;&lt;%=htmlWebpackPlugin.options.title%&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;html-webpack-plugin&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>在 <code>html</code> 模板中，可以通过 <code>&lt;%=htmlWebpackPlugin.options.XXX%&gt;</code> 的方式获取配置的值</p><p><strong>更多的配置</strong></p><ul><li><code>title</code>: ⽤来生成⻚面的 <code>title</code> 元素</li><li><code>filename</code>: 输出的 <code>HTML</code> ⽂件名，默认是 <code>index.html</code>， 也可以直接配置子目录</li><li><code>template</code>: 模板⽂件路径，⽀持加载器（<code>loader</code>），⽐如 <code>html!./index.html</code></li><li><code>inject</code>: <code>true | &#39;head&#39; | &#39;body&#39; | false</code>，注⼊所有的资源到特定的 <code>template</code> 或者 <code>templateContent</code> 中，如果设置为 <code>true</code> 或者 <code>body</code>，所有的 <code>javascript</code> 资源将被放置到 <code>body</code> 元素的底部，<code>&#39;head&#39;</code> 将放置到 <code>head</code> 元素中</li><li><code>favicon</code>: 添加特定的 <code>favicon</code> 路径到输出的 <code>HTML</code> 文件中</li><li><code>minify</code>: <code>&#123;&#125; | false</code>， 传递 <code>html-minifier</code> 选项给 <code>minify</code> 输出</li><li><code>hash</code>: <code>true | false</code>，如果为 <code>true</code>，将添加 <code>webpack</code> 编译生成的 <code>hash</code> 到所有包含的脚本和 <code>CSS</code> ⽂件，对于解除 <code>cache</code> 很有用</li><li><code>cache</code>: <code>true | false</code>，如果为 <code>true</code>，这是默认值，仅在文件修改之后才会发布文件</li><li><code>showErrors</code>: <code>true | false</code>，如果为 <code>true</code>，这是默认值，错误信息会写入到 <code>HTML</code> ⻚面中</li><li><code>chunks</code>: 允许只添加某些块 (⽐如，仅 unit test 块)</li><li><code>chunksSortMode</code>: 允许控制块在添加到⻚面之前的排序方式，⽀持的值:<code>&#39;none&#39; | &#39;default&#39; |&#123;function&#125;-default:&#39;auto&#39;</code></li><li><code>excludeChunks</code>: 允许跳过某些块，(⽐如，跳过单元测试的块)</li></ul><h3 id="8-2、clean-webpack-plugin"><a href="#8-2、clean-webpack-plugin" class="headerlink" title="8 - 2、clean-webpack-plugin"></a>8 - 2、clean-webpack-plugin</h3><p>删除（清理）构建目录</p><pre><code class="bash">npm install --save-dev clean-webpack-plugin</code></pre><pre><code class="js">const &#123;CleanWebpackPlugin&#125; = require(&#39;clean-webpack-plugin&#39;);module.exports = &#123;    ...  plugins: [    ...,    new CleanWebpackPlugin(),    ...  ]&#125;</code></pre><h3 id="8-3、mini-css-extract-plugin"><a href="#8-3、mini-css-extract-plugin" class="headerlink" title="8 - 3、mini-css-extract-plugin"></a>8 - 3、mini-css-extract-plugin</h3><p>提取 <code>CSS</code> 到一个单独的文件中</p><pre><code class="bash">npm install --save-dev mini-css-extract-plugin</code></pre><pre><code class="js">const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);module.exports = &#123;    ...,  module: &#123;      rules: [          &#123;              test: /\.s[ac]ss$/,              use: [                  &#123;                      loader: MiniCssExtractPlugin.loader                    &#125;,          &#39;css-loader&#39;,          &#39;sass-loader&#39;        ]            &#125;      ]    &#125;,  plugins: [    ...,    new MiniCssExtractPlugin(&#123;        filename: &#39;[name].css&#39;    &#125;),    ...  ]&#125;</code></pre><h2 id="9、WebpackDevServer"><a href="#9、WebpackDevServer" class="headerlink" title="9、WebpackDevServer"></a>9、WebpackDevServer</h2><p>每次的代码修改都需要重新编译打包，刷新浏览器，特别麻烦，我们可以通过安装 <code>webpackDevServer</code> 来改善这方面的体验</p><pre><code class="bash">npm install --save-dev webpack-dev-server</code></pre><p>启动命令：</p><pre><code class="bash">npx webpack-dev-server</code></pre><p>或者，<code>package.json</code> 中添加 <code>scripts</code></p><pre><code class="js">...,&quot;scripts&quot;: &#123;  &quot;server&quot;: &quot;webpack-dev-server&quot;&#125;</code></pre><p>修改 <code>webpack.config.js</code></p><pre><code class="js">module.exports = &#123;  ...,  devServer: &#123;      // 扩展的虚拟路径      contentBase: &quot;./abc&quot;,      // 自动开启浏览器      open: true,      // 端口      port: 8081    &#125;&#125;</code></pre><p>启动服务以后，<code>webpack</code> 不在会把打包后的文件生成到硬盘真实目录中了，而是直接存在了内存中(同时虚拟了一个存放目录路径)，后期更新编译打包和访问速度大大提升</p><h3 id="9-1、Proxy"><a href="#9-1、Proxy" class="headerlink" title="9 - 1、Proxy"></a>9 - 1、Proxy</h3><p>当下前端的开发都是前后端分离开发的，前端开发过程中代码会运行在一个服务器环境下(如当前的 <code>WebpackDevServer</code>)，那么在处理一些后端请求的时候通常会出现跨域的问题。<code>WebpackDevServer</code> 内置了一个代理服务，通过内置代理就可以把我们的跨域请求转发目标服务器上(<code>WebpackDevServer</code> 内置的代理发送的请求属于后端 - <code>node</code>，不受同源策略限制)，具体如下：</p><!--后端代码，以 node 为例--><pre><code class="js">const Koa = require(&#39;koa&#39;);const KoaRouter = require(&#39;koa-router&#39;);const app = new Koa();const router = new KoaRouter();router.get(&#39;/api/info&#39;, async ctx =&gt; &#123;    ctx.body = &#123;        username: &#39;zMouse&#39;,        gender: &#39;male&#39;    &#125;&#125;)app.use( router.routes() );app.listen(8787);</code></pre><!--前端代码--><pre><code class="js">axios(&#123;  url: &#39;http://localhost:8787/api/info&#39;&#125;).then(res =&gt; &#123;  console.log(&#39;res&#39;,res.data);&#125;)</code></pre><p>默认情况下，该代码运行以后会出现跨域请求错误，修改 <code>webpack</code> 配置</p><pre><code class="js">module.exports = &#123;  ...,  devServer: &#123;      // 生成的虚拟目录路径      contentBase: &quot;./dist&quot;,      // 自动开启浏览器      open: true,      // 端口      port: 8081,      proxy: &#123;      &#39;/api&#39;: &#123;          target: &#39;http://localhost:8787&#39;        &#125;    &#125;    &#125;&#125;</code></pre><p>通过 <code>proxy</code> 设置，当我们在当前 <code>WebpackDevServer</code> 环境下发送以 <code>/api</code> 开头的请求都会被转发到 <a href="http://localhost:8787/">http://localhost:8787</a> 目标服务器下</p><!--修改前端代码--><pre><code class="js">axios(&#123;  //url: &#39;http://locahost:8081/api/info&#39;,  url: &#39;/api/info&#39;&#125;).then(res =&gt; &#123;  console.log(&#39;res&#39;,res.data);&#125;)</code></pre><p>注意 <code>url</code> 地址要填写 <code>WebpackDevServer</code> 域，比如当前 <code>WebpackDevServer</code> 开启的是 <a href="http://localhost:8081，也就是我们当前前端代码运行的环境，那么请求的">http://localhost:8081，也就是我们当前前端代码运行的环境，那么请求的</a> <code>url</code> 也必须发送到这里，当我们的请求满足了 <code>proxy</code> 中设置的 <code>/api</code> 开头，那么就会把请求转发到 <code>target</code> ，所以最后的实际请求是：<a href="http://lcoahost:8787/api/info">http://lcoahost:8787/api/info</a></p><h3 id="9-2、Hot-Module-Replacement"><a href="#9-2、Hot-Module-Replacement" class="headerlink" title="9 - 2、Hot Module Replacement"></a>9 - 2、Hot Module Replacement</h3><p>在之前当代码有变化，我们使用的 <code>live reload</code>，也就是刷新整个页面，虽然这样为我们省掉了很多手动刷新页面的麻烦，但是这样即使只是修改了很小的内容，也会刷新整个页面，无法保持页面操作状态。<code>HMR</code> 随之就出现了，它的核心的局部（模块）更新，也就是不刷新页面，只更新变化的部分</p><pre><code class="js">module.exports = &#123;  ...,  devServer: &#123;      // 生成的虚拟目录路径      contentBase: &quot;./dist&quot;,      // 自动开启浏览器      open: true,      // 端口      port: 8081,      // 开启热更新      hot:true,      // 即使 HMR 不生效，也不去刷新整个页面(选择开启)    hotOnly:true,      proxy: &#123;      &#39;/api&#39;: &#123;          target: &#39;http://localhost:8787&#39;        &#125;    &#125;    &#125;&#125;</code></pre><p>开启 <code>HMR</code> 以后，当代码发生变化，<code>webpack</code> 即会进行编译，并通过 <code>websocket</code> 通知客户端(浏览器)，我们需要监听处理来自 <code>webpack</code> 的通知，然后通过 <code>HMR</code> 提供的  <code>API</code> 来完成我们的局部更新逻辑</p><!--./fn1.js--><pre><code class="js">export default function() &#123;    console.log(&#39;start1!&#39;);&#125;</code></pre><!--index.js--><pre><code class="js">import fn1 from &#39;./fn1.js&#39;;box1.onclick = fn1;if (module.hot) &#123;//如果开启 HMR    module.hot.accept(&#39;./fn1.js&#39;, function() &#123;      // 更新逻辑      box1.onclick = fn1;    &#125;)&#125;</code></pre><p>上面代码就是 当 .&#x2F;fn1.js 模块代码发生变化的时候，把最新的 fn1 函数绑定到 box1.onclick 上</p><p>从上面就可以看到，<code>HMR</code> 其实就是以模块为单位，当模块代码发生修改的时候，通知客户端进行对应的更新，而客户端则根据具体的模块来更新我们的页面逻辑(这些逻辑需要自己去实现)，好在当前一些常用的更新逻辑都有了现成的插件</p><p><strong>css热更新</strong></p><p>样式热更新比较简单，<code>style-loader</code> 中就已经集成实现了，我们只需要在 <code>use</code> 中使用就可以了</p><p><strong>react 热更新</strong></p><ul><li><p><a href="https://github.com/gaearon/react-hot-loader">https://github.com/gaearon/react-hot-loader</a></p></li><li><p>react 脚手架中也有集成</p></li></ul><p><strong>vue 热更新</strong></p><ul><li><a href="https://github.com/vuejs/vue-loader">https://github.com/vuejs/vue-loader</a></li><li>vue 脚手架中也有集成</li></ul><h2 id="10、sourceMap"><a href="#10、sourceMap" class="headerlink" title="10、sourceMap"></a>10、sourceMap</h2><p>我们实际运行在浏览器的代码是通过 <code>webpack</code> 打包合并甚至是压缩混淆过的代码，所生成的代码并不利于我们的调试和错误定位，我们可以通过 <code>sourceMap</code> 来解决这个问题，<code>sourceMap</code> 本质是一个记录了编译后代码与源代码的映射关系的文件，我们可以通过 <code>webpack</code> 的 <code>devtool</code> 选项来开启 <code>sourceMap</code></p><blockquote><h6 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h6><p>验证 devtool 名称时， 我们期望使用某种模式， 注意不要混淆 devtool 字符串的顺序， 模式是： <code>[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map</code>.</p></blockquote><pre><code class="js">module.exports = &#123;  mode: &#39;production&#39;,  devtool: &#39;source-map&#39;,  ...&#125;</code></pre><p>首先，编译后会为每一个编译文件生成一个对应的 <code>.map</code> 文件，同时在编译文件中添加一段对应的 <code>map</code> 文件引入代码</p><pre><code class="js">...//# sourceMappingURL=xx.js.map</code></pre><pre><code class="css">.../*# sourceMappingURL=xx.css.map*/</code></pre><p>同时，现代浏览器都能够识别 <code>sourceMap</code> 文件，如 <code>chrome</code>，会在 <code>Sources</code> 面板中显示根据编译文件与对应的 <code>map</code> 文件定位到源文件中，有利于我们的调试和错误定位</p><table><thead><tr><th>eval</th><th><em>不支持IE8</em>  可以设断点调试，不显示列信息，每个js模块代码用eval()执行，并且在生成的每个模块代码尾部加上注释，如WEBPACK FOOTER；module id（模块在数组中的索引） ；sourceURL（原js路径）。不会生成*.map*文件</th></tr></thead><tbody><tr><td>source-map</td><td>可以设断点调试，不显示列信息，生成相应的.Map文件，并在合并后的代码尾部加上注释&#x2F;&#x2F;# sourceMappingURL&#x3D;**.js.map</td></tr><tr><td>eval-source-map</td><td>不能设断点调试，不显示列信息，可以用手动加入debugger调试;参考第一种<strong>eval</strong>模式，跟eval不一样的是其用base64存储map信息，不会生成.Map文件，Map信息以Base64格式存放在每个模块代码的尾部</td></tr><tr><td>cheap-source-map</td><td>可以设断点调试，不显示列信息，生成相应的.Map文件，可参考source-map，不包含 loader 的 sourcemap</td></tr><tr><td>cheap-module-source-map</td><td>不包含列信息，同时 loader 的 sourcemap 也被简化为只包含对应行的。最终的 sourcemap 只有一份，它是 webpack 对 loader 生成的 sourcemap 进行简化，然后再次生成的。</td></tr></tbody></table><h2 id="11、Code-Spliting"><a href="#11、Code-Spliting" class="headerlink" title="11、Code Spliting"></a>11、Code Spliting</h2><p>将代码分割到多个不同的bundle(打包后)文件中，可以通过按需加载等方式对资源进行加载，使用合理的情况下可以极大影响加载速度。</p><h3 id="11-1、入口起点"><a href="#11-1、入口起点" class="headerlink" title="11 - 1、入口起点"></a>11 - 1、入口起点</h3><p>通过设置多个入口文件的方式实现最简单的代码分割</p><pre><code class="js">entry: &#123;  index: &quot;./src/index.js&quot;,  list: &quot;./src/list.js&quot;,&#125;,output: &#123;  path: resolve(__dirname, &quot;../dist&quot;),  // 多入口文件的filename不能写死名称，需要通过[name]配置  filename: &quot;js/[name].js&quot;,&#125;</code></pre><h3 id="11-2、防止重复"><a href="#11-2、防止重复" class="headerlink" title="11 - 2、防止重复"></a>11 - 2、防止重复</h3><p>通过设置dependOn配置多个模块之间的共享</p><pre><code class="js">entry: &#123;  index: &#123;    import: &quot;./src/index.js&quot;,    dependOn: &quot;axios&quot;,  &#125;,  list: &#123;      import: &quot;./src/list.js&quot;,      dependOn: &quot;axios&quot;,  &#125;,  axios: &quot;axios&quot;,&#125;,</code></pre><blockquote><p>When you opt-in to code splitting, Webpack may duplicate modules between chunks depending on <a href="https://webpack.js.org/plugins/split-chunks-plugin/#defaults">heuristics</a>. If this happens, then you can end up with multiple instances of the same module, each with their own state that can easily get out of sync.</p><p>However, you can set <a href="https://webpack.js.org/configuration/optimization/#optimizationruntimechunk"><code>optimization.runtimeChunk</code></a> to . This moves Webpack’s runtime module loader into its own bundle rather than being inlined into each entry, creating a global registry that allows code-splitted modules to be shared between entries. This doesn’t prevent Webpack from copying module code between entry points, but it prevents it creating two instances of the same module at runtime, while reducing the number of HTTP requests needed to load modules for a given page.<code>&quot;single&quot;</code></p><p>当你选择使用代码分割时，webpack可能会受<a href="https://webpack.js.org/plugins/split-chunks-plugin/#defaults">启发式</a>的在多个chunk中复制依赖模块。如果发生了这种事情，这时您有可能得到相同模块的多个实例，他们之间的状态将会很难保证同步。</p><p>当然，您可以通过设置 <a href="https://webpack.js.org/configuration/optimization/#optimizationruntimechunk"><code>optimization.runtimeChunk</code></a>为<code>“single”</code>进行解决 。这会将Webpack的运行时模块加载程序移到它自己的包中，而不是内联到每个条目中，从而创建一个全局注册表，允许在条目之间共享代码分割的模块。这并不能阻止Webpack在入口点之间复制模块代码，但它可以防止Webpack在运行时创建同一模块的两个实例，同时减少为给定页面加载模块所需的HTTP请求数。</p><p><code>runtimeChunk: &quot;single&quot;</code>是对于确保模块实例化正确所必须的，它默认是禁用状态，这在<a href="https://webpack.js.org/guides/code-splitting/">Webpack代码分割指南</a>中记载着。</p><p>Although using multiple entry points per page is allowed in webpack, it should be avoided when possible in favor of an entry point with multiple imports: <code>entry: &#123; page: [&#39;./analytics&#39;, &#39;./app&#39;] &#125;</code>. This results in a better optimization and consistent execution order when using <code>async</code> script tags.</p><p>尽管我们可以在webpack中对每个页面配置多入口，但我们应当避免像<code>entry: &#123; page: [&#39;./analytics&#39;, &#39;./app&#39;] &#125;</code>这样的多入口使用多引入的情况。这会让我们在使用<code>async</code>属性的<code>script</code>标签时获得更好的优化以及保证其一致的执行顺序。</p></blockquote><h4 id="11-2-1、SplitChunksPlugin"><a href="#11-2-1、SplitChunksPlugin" class="headerlink" title="11 - 2 - 1、SplitChunksPlugin"></a>11 - 2 - 1、SplitChunksPlugin</h4><p>将公共的依赖模块提取到已有的入口chunk文件或新的chunk文件当中</p><pre><code class="js">entry: &#123;  index: &quot;./src/index.js&quot;,  list: &quot;./src/list.js&quot;,&#125;,optimization: &#123;  splitChunks: &#123;    // async表示只从异步加载得模块（动态加载import()）里面进行拆分    // initial表示只从入口模块进行拆分    // all表示以上两者都包括    chunks: &quot;all&quot;,  &#125;,&#125;</code></pre><pre><code class="js">// 默认配置optimization: &#123;  splitChunks: &#123;    chunks: &#39;async&#39;,    minSize: 20000,    minRemainingSize: 0,    minChunks: 1,    maxAsyncRequests: 30,    maxInitialRequests: 30,    enforceSizeThreshold: 50000,    cacheGroups: &#123;      defaultVendors: &#123;        test: /[\\/]node_modules[\\/]/,        priority: -10,        reuseExistingChunk: true,      &#125;,      default: &#123;        minChunks: 2,        priority: -20,        reuseExistingChunk: true,      &#125;,    &#125;,  &#125;,&#125;,</code></pre><h3 id="11-3、动态导入"><a href="#11-3、动态导入" class="headerlink" title="11 - 3、动态导入"></a>11 - 3、动态导入</h3><p>通过<code>import()</code>动态导入模块，可以通过内联注释对chunk进行一些配置</p><p><a href="https://webpack.docschina.org/api/module-methods/#magic-comments">模块方法 | webpack 中文文档 (docschina.org)</a></p><pre><code class="js">import(/* webpackChunkName: &#39;data&#39;, webpackPreload: true*/ &#39;./data&#39;)    .then(data =&gt; &#123;        console.log(data);    &#125;)</code></pre><h2 id="12、预加载-x2F-预获取"><a href="#12、预加载-x2F-预获取" class="headerlink" title="12、预加载&#x2F;预获取"></a>12、预加载&#x2F;预获取</h2><p>通过内联注释<code>webpackPrefetch</code>和<code>webpackPreload</code>两种资源提示告知浏览器对资源进行不同的加载处理</p><pre><code class="js">const data = import(/* webpackChunkName: &#39;data&#39;, webpackPreload: true */ &#39;./data.js&#39;)const data = import(/* webpackChunkName: &#39;data&#39;, webpackPrefetch: true */ &#39;./data.js&#39;)</code></pre><blockquote><p>与 prefetch 指令相比，preload 指令有许多不同之处：</p><ul><li>preload chunk 会在父 chunk 加载时，以并行方式开始加载。prefetch chunk 会在父 chunk 加载结束后开始加载。</li><li>preload chunk 具有中等优先级，并立即下载。prefetch chunk 在浏览器闲置时下载。</li><li>preload chunk 会在父 chunk 中立即请求，用于当下时刻。prefetch chunk 会用于未来的某个时刻。</li><li>浏览器支持程度不同。</li></ul></blockquote><h2 id="13、外部扩展"><a href="#13、外部扩展" class="headerlink" title="13、外部扩展"></a>13、外部扩展</h2><p>通过externals配置在输出的bundle中排除某些依赖，这些依赖将会在用户环境中所包含。</p><pre><code class="js">externals:   lodash: &#39;_&#39;&#125;,</code></pre><h2 id="14、tree-shaking"><a href="#14、tree-shaking" class="headerlink" title="14、tree shaking"></a>14、tree shaking</h2><p>将上下文中的dead-code移除，就像摇树上的枯叶使其掉落一样</p><pre><code class="js">optimization: &#123;  usedExports: true,&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3+ts+webpack项目搭建</title>
      <link href="/post/34779958.html"/>
      <url>/post/34779958.html</url>
      
        <content type="html"><![CDATA[<h1 id="项目打包和自动化部署"><a href="#项目打包和自动化部署" class="headerlink" title="项目打包和自动化部署"></a>项目打包和自动化部署</h1><h2 id="一-项目部署和DevOps"><a href="#一-项目部署和DevOps" class="headerlink" title="一. 项目部署和DevOps"></a>一. 项目部署和DevOps</h2><h3 id="1-1-传统的开发模式"><a href="#1-1-传统的开发模式" class="headerlink" title="1.1. 传统的开发模式"></a>1.1. 传统的开发模式</h3><p>在传统的开发模式中，开发的整个过程是按部就班就行：</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtt2wf9lezj60xc0b40u102.jpg" alt="早期的开发模式" style="zoom:67%;" /><p>但是这种模式存在很大的弊端：</p><ul><li>工作的不协调：开发人员在开发阶段，测试和运维人员其实是处于等待的状态。等到测试阶段，开发人员等待测试反馈bug，也会处于等待状态。</li><li>线上bug的隐患：项目准备交付时，突然出现了bug，所有人员需要加班、等待问题的处理；</li></ul><h3 id="1-2-DevOps开发模式"><a href="#1-2-DevOps开发模式" class="headerlink" title="1.2. DevOps开发模式"></a>1.2. DevOps开发模式</h3><p>DevOps是Development和Operations两个词的结合，将开发和运维结合起来的模式：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtt32mnaj8j60k007ngmc02.jpg" alt="打开格局"></p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtt33f78kdj60fk0fkgmc02.jpg" alt="DevOps模式" style="zoom:67%;" /><h3 id="1-3-持续集成和持续交付"><a href="#1-3-持续集成和持续交付" class="headerlink" title="1.3. 持续集成和持续交付"></a>1.3. 持续集成和持续交付</h3><p>伴随着DevOps一起出现的两个词就是持续集成和持续交付(部署)：</p><ul><li>CI是Continuous Integration（持续集成）；</li><li>CD是两种翻译：Continuous Delivery（持续交付）或Continuous Deployment（持续部署）；</li></ul><p>持续集成CI：</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtt3bgnnvbj60rs0c8dgu02.jpg" alt="持续集成" style="zoom:67%;" /><p>持续交付和持续部署：</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtt3da1cd2j60rs0kkmz602.jpg" alt="持续交付" style="zoom:67%;" /><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtt3dtbewsj60rs0kk76a02.jpg" alt="持续部署" style="zoom:67%;" /><h3 id="1-4-自动化部署流程"><a href="#1-4-自动化部署流程" class="headerlink" title="1.4. 自动化部署流程"></a>1.4. 自动化部署流程</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtt5buus2kj60wu0lgq7002.jpg" alt="自动化部署的流程"></p><h2 id="二-购买云服务器"><a href="#二-购买云服务器" class="headerlink" title="二. 购买云服务器"></a>二. 购买云服务器</h2><h3 id="2-1-注册阿里云的账号"><a href="#2-1-注册阿里云的账号" class="headerlink" title="2.1. 注册阿里云的账号"></a>2.1. 注册阿里云的账号</h3><p>云服务器我们可以有很多的选择：阿里云、腾讯云、华为云。</p><ul><li>目前在公司使用比较多的是阿里云；</li><li>我自己之前也一直使用阿里云，也在使用腾讯云；</li><li>之前华为云也有找我帮忙推广他们的活动；</li></ul><p>但是在我们的课程中，我选择目前使用更加广泛的阿里云来讲解：</p><p>我们需要注册阿里云账号</p><ul><li><p><a href="https://aliyun.com/">https://aliyun.com/</a></p></li><li><p>注册即可，非常简单</p></li></ul><h3 id="2-2-购买云服务器"><a href="#2-2-购买云服务器" class="headerlink" title="2.2. 购买云服务器"></a>2.2. 购买云服务器</h3><p>购买云服务器其实是购买一个实例。</p><p>1.来到控制台：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glbumqekwhj31ct0p8grl.jpg" alt="image-20201204152032769"></p><p>2.创建实例，选择类型和配置</p><p>![image-20201204152133800](&#x2F;Users&#x2F;coderwhy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20201204152133800.png)</p><p>![image-20201203103047329](&#x2F;Users&#x2F;coderwhy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20201203103047329.png)</p><p>3.配置网络安全组</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glagts0xxuj31at0nyq87.jpg" alt="image-20201203103725892"></p><p>4.创建实例</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glagzdiwnpj31bk0o5433.jpg" alt="image-20201203104249296"></p><h2 id="三-搭建服务器环境"><a href="#三-搭建服务器环境" class="headerlink" title="三. 搭建服务器环境"></a>三. 搭建服务器环境</h2><h3 id="3-1-jenkins自动化部署"><a href="#3-1-jenkins自动化部署" class="headerlink" title="3.1. jenkins自动化部署"></a>3.1. jenkins自动化部署</h3><h4 id="3-1-1-安装Java环境"><a href="#3-1-1-安装Java环境" class="headerlink" title="3.1.1. 安装Java环境"></a>3.1.1. 安装Java环境</h4><p>Jenkins本身是依赖Java的，所以我们需要先安装Java环境：</p><ul><li>这里我安装了Java1.8的环境</li></ul><pre><code class="shell">dnf search java-1.8dnf install java-1.8.0-openjdk.x86_64</code></pre><h4 id="3-1-2-安装Jenkins"><a href="#3-1-2-安装Jenkins" class="headerlink" title="3.1.2. 安装Jenkins"></a>3.1.2. 安装Jenkins</h4><p>因为Jenkins本身是没有在dnf的软件仓库包中的，所以我们需要连接Jenkins仓库：</p><ul><li>wget是Linux中下载文件的一个工具，-O表示输出到某个文件夹并且命名为什么文件；</li><li>rpm：全称为<strong>The RPM Package Manage</strong>，是Linux下一个软件包管理器；</li></ul><pre><code class="shell">wget –O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat-stable/jenkins.repo# 导入GPG密钥以确保您的软件合法rpm --import https://pkg.jenkins.io/redhat/jenkins.io.key# 或者rpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key</code></pre><p>编辑一下文件&#x2F;etc&#x2F;yum.repos.d&#x2F;jenkins.repo</p><ul><li>可以通过vim编辑</li></ul><pre><code>[jenkins]name=Jenkins-stablebaseurl=http://pkg.jenkins.io/redhatgpgcheck=1</code></pre><p>安装Jenkins</p><pre><code class="shell">dnf install jenkins # --nogpgcheck(可以不加)</code></pre><p>启动Jenkins的服务：</p><pre><code class="shell">systemctl start jenkinssystemctl status jenkinssystemctl enable jenkins</code></pre><p>Jenkins默认使用8080端口提供服务，所以需要加入到安全组中：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glbyeoz6tqj315w0bzmzj.jpg" alt="image-20201204173117359"></p><h4 id="3-1-3-Jenkins用户"><a href="#3-1-3-Jenkins用户" class="headerlink" title="3.1.3. Jenkins用户"></a>3.1.3. Jenkins用户</h4><p>我们后面会访问centos中的某些文件夹，默认Jenkins使用的用户是 <code>jenkins</code>，可能会没有访问权限，所以我们需要修改一下它的用户：</p><p>修改文件的路径：<code>/etc/sysconfig/jenkins</code></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtt46oxg53j60n00aw75302.jpg" alt="image-20210825162827962"></p><p>之后需要重启一下Jenkins：</p><pre><code class="shell">systemctl restart jenkins</code></pre><h4 id="3-1-4-Jenkins配置"><a href="#3-1-4-Jenkins配置" class="headerlink" title="3.1.4. Jenkins配置"></a>3.1.4. Jenkins配置</h4><p>打开浏览器，输入：<a href="http://8.134.60.235:8080/">http://8.134.60.235:8080/</a></p><ul><li>注意：你输入自己的IP地址</li></ul><p>获取输入管理员密码：</p><ul><li>在下面的地址中 <code>cat /var/lib/jenkins/secrets/initialAdminPassword</code></li></ul><p>![image-20201203173047824](&#x2F;Users&#x2F;coderwhy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20201203173047824.png)</p><p>可以安装推荐的插件：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glbylb26ouj30fb082js7.jpg" alt="安装推荐的插件"></p><h4 id="3-1-5-Jenkins任务"><a href="#3-1-5-Jenkins任务" class="headerlink" title="3.1.5. Jenkins任务"></a>3.1.5. Jenkins任务</h4><p><strong>新建任务：</strong></p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glc0uinjzej30pa0fet9z.jpg" alt="新建任务"></p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glc0v225vaj30wl0hkn05.jpg" alt="image-20201204185613061"></p><p><strong>配置项目和保留策略：</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtt3l4fjm6j614p0d2dgl02.jpg" alt="image-20210825160744119"></p><p><strong>源码管理：</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtt3lpcvtgj614k0j8jsn02.jpg" alt="image-20210825160818122"></p><p><strong>构建触发器：</strong></p><p>这里的触发器规则是这样的：</p><ul><li>定时字符串从左往右分别是：分 时 日 月 周</li></ul><pre><code class="js">#每半小时构建一次OR每半小时检查一次远程代码分支，有更新则构建H/30 * * * *#每两小时构建一次OR每两小时检查一次远程代码分支，有更新则构建H H/2 * * *#每天凌晨两点定时构建H 2 * * *#每月15号执行构建H H 15 * *#工作日，上午9点整执行H 9 * * 1-5#每周1,3,5，从8:30开始，截止19:30，每4小时30分构建一次H/30 8-20/4 * * 1,3,5</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtt419gw6tj614g0agmy402.jpg" alt="触发器"></p><p><strong>构建环境：</strong></p><p>注意：我们需要搭建Node的环境</p><ul><li>第一步：配置Node的环境；</li><li>第二步：安装Node的插件；</li></ul><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glc0zyecd4j31ar0ecjuz.jpg" alt="image-20201204190055096"></p><p>第一步：配置Node的环境</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtt42elwduj614h0elwfq02.jpg" alt="node环境"></p><p>第二步：安装Node的插件</p><ul><li>这里因为我已经安装过了，所以没有搜索到；</li></ul><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glc0yta64bj30r907caam.jpg" alt="image-20201204185949452"></p><p>构建执行的任务：</p><ul><li>查看Node的版本等是否有问题；</li><li>执行 <code>npm install</code> 安装项目的依赖；</li><li>移除原来mall_cms文件的所有内容；</li><li>将打包的dist文件夹内容移动到mall_cms文件夹；</li></ul><pre><code class="shell">pwdnode -vnpm -vnpm install npm run buildpwdecho &#39;构建成功&#39;ls# 删除/root/mall_cms文件夹里所有的内容rm -rf /root/mall_cms/* cp -rf ./dist/* /root/mall_cms/</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtt43sz933j614o0dy0tk02.jpg" alt="执行构建任务"></p><h3 id="3-2-nginx安装和配置"><a href="#3-2-nginx安装和配置" class="headerlink" title="3.2. nginx安装和配置"></a>3.2. nginx安装和配置</h3><h4 id="3-2-1-安装nginx"><a href="#3-2-1-安装nginx" class="headerlink" title="3.2.1. 安装nginx"></a>3.2.1. 安装nginx</h4><p>后续我们部署会使用nginx，所以需要先安装一下nginx：</p><pre><code class="shell">dnf install nginx</code></pre><p>启动nginx：</p><pre><code class="shell">systemctl start nginxsystemctl status nginxsystemctl enable nginx</code></pre><h4 id="3-2-2-配置nginx"><a href="#3-2-2-配置nginx" class="headerlink" title="3.2.2. 配置nginx"></a>3.2.2. 配置nginx</h4><p>我们这里主要配置nginx的用户和默认访问目录：</p><p>配置用户：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtt4bwvxc4j60f30453yk02.jpg" alt="image-20210825163329209"></p><p>通过Linux命令创建文件夹和文件：</p><pre><code class="shell">mkdir /root/mall_cmscd /root/mall_cmstouch index.htmlvi index.html</code></pre><p>配置访问目录：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtt4cka6hgj60n00bwgmc02.jpg" alt="image-20210825163406566"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3+ts+webpack项目搭建</title>
      <link href="/post/34779958.html"/>
      <url>/post/34779958.html</url>
      
        <content type="html"><![CDATA[<p>使用VUE3开发很久了，但一直没进行总结和记录，忙里偷闲整理搭建一套VUE3项目脚手架，正好记录一下，按照我的教程让你开启vue3之旅吧！</p><span id="more"></span><h1 id="项目搭建规范"><a href="#项目搭建规范" class="headerlink" title="项目搭建规范"></a>项目搭建规范</h1><h2 id="一-代码规范"><a href="#一-代码规范" class="headerlink" title="一. 代码规范"></a>一. 代码规范</h2><h3 id="1-1-集成editorconfig配置"><a href="#1-1-集成editorconfig配置" class="headerlink" title="1.1. 集成editorconfig配置"></a>1.1. 集成editorconfig配置</h3><p>EditorConfig 有助于为不同 IDE 编辑器上处理同一项目的多个开发人员维护一致的编码风格。</p><pre><code class="yaml"># http://editorconfig.orgroot = true[*] # 表示所有文件适用charset = utf-8 # 设置文件字符集为 utf-8indent_style = space # 缩进风格（tab | space）indent_size = 2 # 缩进大小end_of_line = lf # 控制换行类型(lf | cr | crlf)trim_trailing_whitespace = true # 去除行首的任意空白字符insert_final_newline = true # 始终在文件末尾插入一个新行[*.md] # 表示仅 md 文件适用以下规则max_line_length = offtrim_trailing_whitespace = false</code></pre><p>VSCode需要安装一个插件：EditorConfig for VS Code</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsq2gh989yj30pj05ggmb.jpg" alt="image-20210722215138665"></p><h3 id="1-2-使用prettier工具"><a href="#1-2-使用prettier工具" class="headerlink" title="1.2. 使用prettier工具"></a>1.2. 使用prettier工具</h3><p>Prettier 是一款强大的代码格式化工具，支持 JavaScript、TypeScript、CSS、SCSS、Less、JSX、Angular、Vue、GraphQL、JSON、Markdown 等语言，基本上前端能用到的文件格式它都可以搞定，是当下最流行的代码格式化工具。</p><p>1.安装prettier</p><pre><code class="shell">npm install prettier -D</code></pre><p>2.配置.prettierrc文件：</p><ul><li>useTabs：使用tab缩进还是空格缩进，选择false；</li><li>tabWidth：tab是空格的情况下，是几个空格，选择2个；</li><li>printWidth：当行字符的长度，推荐80，也有人喜欢100或者120；</li><li>singleQuote：使用单引号还是双引号，选择true，使用单引号；</li><li>trailingComma：在多行输入的尾逗号是否添加，设置为 <code>none</code>；</li><li>semi：语句末尾是否要加分号，默认值true，选择false表示不加；</li></ul><pre><code class="json">&#123;  &quot;useTabs&quot;: false,  &quot;tabWidth&quot;: 2,  &quot;printWidth&quot;: 80,  &quot;singleQuote&quot;: true,  &quot;trailingComma&quot;: &quot;none&quot;,  &quot;semi&quot;: false&#125;</code></pre><p>3.创建.prettierignore忽略文件</p><pre><code>/dist/*.local.output.js/node_modules/****/*.svg**/*.sh/public/*</code></pre><p>4.VSCode需要安装prettier的插件</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsq2acx21rj30ow057mxp.jpg" alt="image-20210722214543454"></p><p>5.测试prettier是否生效</p><ul><li>测试一：在代码中保存代码；</li><li>测试二：配置一次性修改的命令；</li></ul><p>在package.json中配置一个scripts：</p><pre><code class="json">    &quot;prettier&quot;: &quot;prettier --write .&quot;</code></pre><h3 id="1-3-使用ESLint检测"><a href="#1-3-使用ESLint检测" class="headerlink" title="1.3. 使用ESLint检测"></a>1.3. 使用ESLint检测</h3><p>1.在前面创建项目的时候，我们就选择了ESLint，所以Vue会默认帮助我们配置需要的ESLint环境。</p><p>2.VSCode需要安装ESLint插件：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsq2oq26odj30pw05faaq.jpg" alt="image-20210722215933360"></p><p>3.解决eslint和prettier冲突的问题：</p><p>安装插件：（vue在创建项目时，如果选择prettier，那么这两个插件会自动安装）</p><pre><code class="shell">npm i eslint-plugin-prettier eslint-config-prettier -D</code></pre><p>添加prettier插件：</p><pre><code class="json">  extends: [    &quot;plugin:vue/vue3-essential&quot;,    &quot;eslint:recommended&quot;,    &quot;@vue/typescript/recommended&quot;,    &quot;@vue/prettier&quot;,    &quot;@vue/prettier/@typescript-eslint&quot;,    &#39;plugin:prettier/recommended&#39;  ],</code></pre><h3 id="1-4-git-Husky和eslint"><a href="#1-4-git-Husky和eslint" class="headerlink" title="1.4. git Husky和eslint"></a>1.4. git Husky和eslint</h3><p>虽然我们已经要求项目使用eslint了，但是不能保证组员提交代码之前都将eslint中的问题解决掉了：</p><ul><li><p>也就是我们希望保证代码仓库中的代码都是符合eslint规范的；</p></li><li><p>那么我们需要在组员执行 <code>git commit </code> 命令的时候对其进行校验，如果不符合eslint规范，那么自动通过规范进行修复；</p></li></ul><p>那么如何做到这一点呢？可以通过Husky工具：</p><ul><li>husky是一个git hook工具，可以帮助我们触发git提交的各个阶段：pre-commit、commit-msg、pre-push</li></ul><p>如何使用husky呢？</p><p>这里我们可以使用自动配置命令：</p><pre><code class="shell">npx husky-init &amp;&amp; npm install</code></pre><p>这里会做三件事：</p><p>1.安装husky相关的依赖：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqq0o5jxmj30bb04qwen.jpg" alt="image-20210723112648927"></p><p>2.在项目目录下创建 <code>.husky</code> 文件夹：</p><pre><code>npx huksy install</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqq16zo75j307703mt8m.jpg" alt="image-20210723112719634"></p><p>3.在package.json中添加一个脚本：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqq26phpxj30dj06fgm3.jpg" alt="image-20210723112817691"></p><p>接下来，我们需要去完成一个操作：在进行commit时，执行lint脚本：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqq3hn229j30nf04z74q.jpg" alt="image-20210723112932943"></p><p>这个时候我们执行git commit的时候会自动对代码进行lint校验。</p><h3 id="1-5-git-commit规范"><a href="#1-5-git-commit规范" class="headerlink" title="1.5. git commit规范"></a>1.5. git commit规范</h3><h4 id="1-5-1-代码提交风格"><a href="#1-5-1-代码提交风格" class="headerlink" title="1.5.1. 代码提交风格"></a>1.5.1. 代码提交风格</h4><p>通常我们的git commit会按照统一的风格来提交，这样可以快速定位每次提交的内容，方便之后对版本进行控制。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw17gaqjj30to0cj3zp.jpg"></p><p>但是如果每次手动来编写这些是比较麻烦的事情，我们可以使用一个工具：Commitizen</p><ul><li>Commitizen 是一个帮助我们编写规范 commit message 的工具；</li></ul><p>1.安装Commitizen</p><pre><code class="shell">npm install commitizen -D</code></pre><p>2.安装cz-conventional-changelog，并且初始化cz-conventional-changelog：</p><pre><code class="shell">npx commitizen init cz-conventional-changelog --save-dev --save-exact</code></pre><p>这个命令会帮助我们安装cz-conventional-changelog：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqvz2odi4j30ek00zmx2.jpg" alt="image-20210723145249096"></p><p>并且在package.json中进行配置：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqvzftay5j30iu04k74d.jpg"></p><p>这个时候我们提交代码需要使用 <code>npx cz</code>：</p><ul><li>第一步是选择type，本次更新的类型</li></ul><table><thead><tr><th>Type</th><th>作用</th></tr></thead><tbody><tr><td>feat</td><td>新增特性 (feature)</td></tr><tr><td>fix</td><td>修复 Bug(bug fix)</td></tr><tr><td>docs</td><td>修改文档 (documentation)</td></tr><tr><td>style</td><td>代码格式修改(white-space, formatting, missing semi colons, etc)</td></tr><tr><td>refactor</td><td>代码重构(refactor)</td></tr><tr><td>perf</td><td>改善性能(A code change that improves performance)</td></tr><tr><td>test</td><td>测试(when adding missing tests)</td></tr><tr><td>build</td><td>变更项目构建或外部依赖（例如 scopes: webpack、gulp、npm 等）</td></tr><tr><td>ci</td><td>更改持续集成软件的配置文件和 package 中的 scripts 命令，例如 scopes: Travis, Circle 等</td></tr><tr><td>chore</td><td>变更构建流程或辅助工具(比如更改测试环境)</td></tr><tr><td>revert</td><td>代码回退</td></tr></tbody></table><ul><li>第二步选择本次修改的范围（作用域）</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw8ca15oj30r600wmx4.jpg" alt="image-20210723150147510"></p><ul><li>第三步选择提交的信息</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw8mq3zlj60ni01hmx402.jpg" alt="image-20210723150204780"></p><ul><li>第四步提交详细的描述信息</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw8y05bjj30kt01fjrb.jpg" alt="image-20210723150223287"></p><ul><li>第五步是否是一次重大的更改</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw9z5vbij30bm00q744.jpg" alt="image-20210723150322122"></p><ul><li>第六步是否影响某个open issue</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqwar8xp1j30fq00ya9x.jpg" alt="image-20210723150407822"></p><p>我们也可以在scripts中构建一个命令来执行 cz：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqwc4gtkxj30e207174t.jpg" alt="image-20210723150526211"></p><h4 id="1-5-2-代码提交验证"><a href="#1-5-2-代码提交验证" class="headerlink" title="1.5.2. 代码提交验证"></a>1.5.2. 代码提交验证</h4><p>如果我们按照cz来规范了提交风格，但是依然有同事通过 <code>git commit</code> 按照不规范的格式提交应该怎么办呢？</p><ul><li>我们可以通过commitlint来限制提交；</li></ul><p>1.安装 @commitlint&#x2F;config-conventional 和 @commitlint&#x2F;cli</p><pre><code class="shell">npm i @commitlint/config-conventional @commitlint/cli -D</code></pre><p>2.在根目录创建commitlint.config.js文件，配置commitlint</p><pre><code class="js">module.exports = &#123;  extends: [&#39;@commitlint/config-conventional&#39;]&#125;</code></pre><p>3.使用husky生成commit-msg文件，验证提交信息：</p><pre><code class="shell">npx husky add .husky/commit-msg &quot;npx --no-install commitlint --edit $1&quot;</code></pre><h2 id="二-第三方库集成"><a href="#二-第三方库集成" class="headerlink" title="二. 第三方库集成"></a>二. 第三方库集成</h2><h3 id="2-1-vue-config-js配置"><a href="#2-1-vue-config-js配置" class="headerlink" title="2.1. vue.config.js配置"></a>2.1. vue.config.js配置</h3><p>vue.config.js有三种配置方式：</p><ul><li>方式一：直接通过CLI提供给我们的选项来配置：<ul><li>比如publicPath：配置应用程序部署的子目录（默认是 <code>/</code>，相当于部署在 <code>https://www.my-app.com/</code>）；</li><li>比如outputDir：修改输出的文件夹；</li></ul></li><li>方式二：通过configureWebpack修改webpack的配置：<ul><li>可以是一个对象，直接会被合并；</li><li>可以是一个函数，会接收一个config，可以通过config来修改配置；</li></ul></li><li>方式三：通过chainWebpack修改webpack的配置：<ul><li>是一个函数，会接收一个基于  <a href="https://github.com/mozilla-neutrino/webpack-chain">webpack-chain</a> 的config对象，可以对配置进行修改；</li></ul></li></ul><pre><code class="js">const path = require(&#39;path&#39;)module.exports = &#123;  outputDir: &#39;./build&#39;,  // configureWebpack: &#123;  //   resolve: &#123;  //     alias: &#123;  //       views: &#39;@/views&#39;  //     &#125;  //   &#125;  // &#125;  // configureWebpack: (config) =&gt; &#123;  //   config.resolve.alias = &#123;  //     &#39;@&#39;: path.resolve(__dirname, &#39;src&#39;),  //     views: &#39;@/views&#39;  //   &#125;  // &#125;,  chainWebpack: (config) =&gt; &#123;    config.resolve.alias.set(&#39;@&#39;, path.resolve(__dirname, &#39;src&#39;)).set(&#39;views&#39;, &#39;@/views&#39;)  &#125;&#125;</code></pre><h3 id="2-2-vue-router集成"><a href="#2-2-vue-router集成" class="headerlink" title="2.2. vue-router集成"></a>2.2. vue-router集成</h3><p>安装vue-router的最新版本：</p><pre><code class="shell">npm install vue-router@next</code></pre><p>创建router对象：</p><pre><code class="ts">import &#123; createRouter, createWebHashHistory &#125; from &#39;vue-router&#39;import &#123; RouteRecordRaw &#125; from &#39;vue-router&#39;const routes: RouteRecordRaw[] = [  &#123;    path: &#39;/&#39;,    redirect: &#39;/main&#39;  &#125;,  &#123;    path: &#39;/main&#39;,    component: () =&gt; import(&#39;../views/main/main.vue&#39;)  &#125;,  &#123;    path: &#39;/login&#39;,    component: () =&gt; import(&#39;../views/login/login.vue&#39;)  &#125;]const router = createRouter(&#123;  routes,  history: createWebHashHistory()&#125;)export default router</code></pre><p>安装router：</p><pre><code class="ts">import router from &#39;./router&#39;createApp(App).use(router).mount(&#39;#app&#39;)</code></pre><p>在App.vue中配置跳转：</p><pre><code class="html">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;    &lt;router-link to=&quot;/main&quot;&gt;首页&lt;/router-link&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h3 id="2-3-vuex集成"><a href="#2-3-vuex集成" class="headerlink" title="2.3. vuex集成"></a>2.3. vuex集成</h3><p>安装vuex：</p><pre><code class="shell">npm install vuex@next</code></pre><p>创建store对象：</p><pre><code class="ts">import &#123; createStore &#125; from &#39;vuex&#39;const store = createStore(&#123;  state() &#123;    return &#123;      name: &#39;coderwhy&#39;    &#125;  &#125;&#125;)export default store</code></pre><p>安装store：</p><pre><code class="ts">createApp(App).use(router).use(store).mount(&#39;#app&#39;)</code></pre><p>在App.vue中使用：</p><pre><code class="html">&lt;h2&gt;&#123;&#123; $store.state.name &#125;&#125;&lt;/h2&gt;</code></pre><h3 id="2-4-element-plus集成"><a href="#2-4-element-plus集成" class="headerlink" title="2.4. element-plus集成"></a>2.4. element-plus集成</h3><p>Element Plus，一套为开发者、设计师和产品经理准备的基于 Vue 3.0 的桌面端组件库：</p><ul><li>相信很多同学在Vue2中都使用过element-ui，而element-plus正是element-ui针对于vue3开发的一个UI组件库；</li><li>它的使用方式和很多其他的组件库是一样的，所以学会element-plus，其他类似于ant-design-vue、NaiveUI、VantUI都是差不多的；</li></ul><p>安装element-plus</p><pre><code class="shell">npm install element-plus</code></pre><h4 id="2-4-1-全局引入"><a href="#2-4-1-全局引入" class="headerlink" title="2.4.1. 全局引入"></a>2.4.1. 全局引入</h4><p>一种引入element-plus的方式是全局引入，代表的含义是所有的组件和插件都会被自动注册：</p><pre><code class="js">import ElementPlus from &#39;element-plus&#39;import &#39;element-plus/lib/theme-chalk/index.css&#39;import router from &#39;./router&#39;import store from &#39;./store&#39;createApp(App).use(router).use(store).use(ElementPlus).mount(&#39;#app&#39;)</code></pre><h4 id="2-4-2-局部引入"><a href="#2-4-2-局部引入" class="headerlink" title="2.4.2. 局部引入"></a>2.4.2. 局部引入</h4><p>也就是在开发中用到某个组件对某个组件进行引入：</p><pre><code class="vue">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;    &lt;router-link to=&quot;/main&quot;&gt;首页&lt;/router-link&gt;    &lt;router-view&gt;&lt;/router-view&gt;    &lt;h2&gt;&#123;&#123; $store.state.name &#125;&#125;&lt;/h2&gt;    &lt;el-button&gt;默认按钮&lt;/el-button&gt;    &lt;el-button type=&quot;primary&quot;&gt;主要按钮&lt;/el-button&gt;    &lt;el-button type=&quot;success&quot;&gt;成功按钮&lt;/el-button&gt;    &lt;el-button type=&quot;info&quot;&gt;信息按钮&lt;/el-button&gt;    &lt;el-button type=&quot;warning&quot;&gt;警告按钮&lt;/el-button&gt;    &lt;el-button type=&quot;danger&quot;&gt;危险按钮&lt;/el-button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; defineComponent &#125; from &#39;vue&#39;import &#123; ElButton &#125; from &#39;element-plus&#39;export default defineComponent(&#123;  name: &#39;App&#39;,  components: &#123;    ElButton  &#125;&#125;)&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;&lt;/style&gt;</code></pre><p>但是我们会发现是没有对应的样式的，引入样式有两种方式：</p><ul><li>全局引用样式（像之前做的那样）；</li><li>局部引用样式（通过babel的插件）；</li></ul><p>1.安装babel的插件：</p><pre><code class="shell">npm install babel-plugin-import -D</code></pre><p>2.配置babel.config.js</p><pre><code class="js">module.exports = &#123;  plugins: [    [      &#39;import&#39;,      &#123;        libraryName: &#39;element-plus&#39;,        customStyleName: (name) =&gt; &#123;          return `element-plus/lib/theme-chalk/$&#123;name&#125;.css`        &#125;      &#125;    ]  ],  presets: [&#39;@vue/cli-plugin-babel/preset&#39;]&#125;</code></pre><p>但是这里依然有个弊端：</p><ul><li>这些组件我们在多个页面或者组件中使用的时候，都需要导入并且在components中进行注册；</li><li>所以我们可以将它们在全局注册一次；</li></ul><pre><code class="ts">import &#123;  ElButton,  ElTable,  ElAlert,  ElAside,  ElAutocomplete,  ElAvatar,  ElBacktop,  ElBadge,&#125; from &#39;element-plus&#39;const app = createApp(App)const components = [  ElButton,  ElTable,  ElAlert,  ElAside,  ElAutocomplete,  ElAvatar,  ElBacktop,  ElBadge]for (const cpn of components) &#123;  app.component(cpn.name, cpn)&#125;</code></pre><h3 id="2-5-axios集成"><a href="#2-5-axios集成" class="headerlink" title="2.5. axios集成"></a>2.5. axios集成</h3><p>安装axios：</p><pre><code class="shell">npm install axios</code></pre><p>封装axios：</p><pre><code class="ts">import axios, &#123; AxiosInstance, AxiosRequestConfig, AxiosResponse &#125; from &#39;axios&#39;import &#123; Result &#125; from &#39;./types&#39;import &#123; useUserStore &#125; from &#39;/@/store/modules/user&#39;class HYRequest &#123;  private instance: AxiosInstance  private readonly options: AxiosRequestConfig  constructor(options: AxiosRequestConfig) &#123;    this.options = options    this.instance = axios.create(options)    this.instance.interceptors.request.use(      (config) =&gt; &#123;        const token = useUserStore().getToken        if (token) &#123;          config.headers.Authorization = `Bearer $&#123;token&#125;`        &#125;        return config      &#125;,      (err) =&gt; &#123;        return err      &#125;    )    this.instance.interceptors.response.use(      (res) =&gt; &#123;        // 拦截响应的数据        if (res.data.code === 0) &#123;          return res.data.data        &#125;        return res.data      &#125;,      (err) =&gt; &#123;        return err      &#125;    )  &#125;  request&lt;T = any&gt;(config: AxiosRequestConfig): Promise&lt;T&gt; &#123;    return new Promise((resolve, reject) =&gt; &#123;      this.instance        .request&lt;any, AxiosResponse&lt;Result&lt;T&gt;&gt;&gt;(config)        .then((res) =&gt; &#123;          resolve((res as unknown) as Promise&lt;T&gt;)        &#125;)        .catch((err) =&gt; &#123;          reject(err)        &#125;)    &#125;)  &#125;  get&lt;T = any&gt;(config: AxiosRequestConfig): Promise&lt;T&gt; &#123;    return this.request(&#123; ...config, method: &#39;GET&#39; &#125;)  &#125;  post&lt;T = any&gt;(config: AxiosRequestConfig): Promise&lt;T&gt; &#123;    return this.request(&#123; ...config, method: &#39;POST&#39; &#125;)  &#125;  patch&lt;T = any&gt;(config: AxiosRequestConfig): Promise&lt;T&gt; &#123;    return this.request(&#123; ...config, method: &#39;PATCH&#39; &#125;)  &#125;  delete&lt;T = any&gt;(config: AxiosRequestConfig): Promise&lt;T&gt; &#123;    return this.request(&#123; ...config, method: &#39;DELETE&#39; &#125;)  &#125;&#125;export default HYRequest</code></pre><h3 id="2-6-VSCode配置"><a href="#2-6-VSCode配置" class="headerlink" title="2.6. VSCode配置"></a>2.6. VSCode配置</h3><pre><code class="json">&#123;  &quot;workbench.iconTheme&quot;: &quot;vscode-great-icons&quot;,  &quot;editor.fontSize&quot;: 17,  &quot;eslint.migration.2_x&quot;: &quot;off&quot;,  &quot;[javascript]&quot;: &#123;    &quot;editor.defaultFormatter&quot;: &quot;dbaeumer.vscode-eslint&quot;  &#125;,  &quot;files.autoSave&quot;: &quot;afterDelay&quot;,  &quot;editor.tabSize&quot;: 2,  &quot;terminal.integrated.fontSize&quot;: 16,  &quot;editor.renderWhitespace&quot;: &quot;all&quot;,  &quot;editor.quickSuggestions&quot;: &#123;    &quot;strings&quot;: true  &#125;,  &quot;debug.console.fontSize&quot;: 15,  &quot;window.zoomLevel&quot;: 1,  &quot;emmet.includeLanguages&quot;: &#123;    &quot;javascript&quot;: &quot;javascriptreact&quot;  &#125;,  &quot;explorer.confirmDragAndDrop&quot;: false,  &quot;workbench.tree.indent&quot;: 16,  &quot;javascript.updateImportsOnFileMove.enabled&quot;: &quot;always&quot;,  &quot;editor.wordWrap&quot;: &quot;on&quot;,  &quot;path-intellisense.mappings&quot;: &#123;    &quot;@&quot;: &quot;$&#123;workspaceRoot&#125;/src&quot;  &#125;,  &quot;hediet.vscode-drawio.local-storage&quot;: &quot;eyIuZHJhd2lvLWNvbmZpZyI6IntcImxhbmd1YWdlXCI6XCJcIixcImN1c3RvbUZvbnRzXCI6W10sXCJsaWJyYXJpZXNcIjpcImdlbmVyYWw7YmFzaWM7YXJyb3dzMjtmbG93Y2hhcnQ7ZXI7c2l0ZW1hcDt1bWw7YnBtbjt3ZWJpY29uc1wiLFwiY3VzdG9tTGlicmFyaWVzXCI6W1wiTC5zY3JhdGNocGFkXCJdLFwicGx1Z2luc1wiOltdLFwicmVjZW50Q29sb3JzXCI6W1wiRkYwMDAwXCIsXCIwMENDNjZcIixcIm5vbmVcIixcIkNDRTVGRlwiLFwiNTI1MjUyXCIsXCJGRjMzMzNcIixcIjMzMzMzM1wiLFwiMzMwMDAwXCIsXCIwMENDQ0NcIixcIkZGNjZCM1wiLFwiRkZGRkZGMDBcIl0sXCJmb3JtYXRXaWR0aFwiOjI0MCxcImNyZWF0ZVRhcmdldFwiOmZhbHNlLFwicGFnZUZvcm1hdFwiOntcInhcIjowLFwieVwiOjAsXCJ3aWR0aFwiOjExNjksXCJoZWlnaHRcIjoxNjU0fSxcInNlYXJjaFwiOnRydWUsXCJzaG93U3RhcnRTY3JlZW5cIjp0cnVlLFwiZ3JpZENvbG9yXCI6XCIjZDBkMGQwXCIsXCJkYXJrR3JpZENvbG9yXCI6XCIjNmU2ZTZlXCIsXCJhdXRvc2F2ZVwiOnRydWUsXCJyZXNpemVJbWFnZXNcIjpudWxsLFwib3BlbkNvdW50ZXJcIjowLFwidmVyc2lvblwiOjE4LFwidW5pdFwiOjEsXCJpc1J1bGVyT25cIjpmYWxzZSxcInVpXCI6XCJcIn0ifQ==&quot;,  &quot;hediet.vscode-drawio.theme&quot;: &quot;Kennedy&quot;,  &quot;editor.fontFamily&quot;: &quot;Source Code Pro, &#39;Courier New&#39;, monospace&quot;,  &quot;editor.smoothScrolling&quot;: true,  &quot;editor.formatOnSave&quot;: true,  &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;,  &quot;workbench.colorTheme&quot;: &quot;Atom One Dark&quot;,  &quot;vetur.completion.autoImport&quot;: false,  &quot;security.workspace.trust.untrustedFiles&quot;: &quot;open&quot;,  &quot;eslint.lintTask.enable&quot;: true,  &quot;eslint.alwaysShowStatus&quot;: true,  &quot;editor.codeActionsOnSave&quot;: &#123;    &quot;source.fixAll.eslint&quot;: true  &#125;&#125;</code></pre><h2 id="三-接口文档"><a href="#三-接口文档" class="headerlink" title="三. 接口文档"></a>三. 接口文档</h2><p><a href="https://documenter.getpostman.com/view/12387168/TzsfmQvw">https://documenter.getpostman.com/view/12387168/TzsfmQvw</a></p><p>baseURL的值：</p><pre><code>http://152.136.185.210:5000</code></pre><p>设置全局token的方法：</p><pre><code class="js">const res = pm.response.json();pm.globals.set(&quot;token&quot;, res.data.token);</code></pre><p>接口文档v2版本：（有部分更新）</p><p><a href="https://documenter.getpostman.com/view/12387168/TzzDKb12">https://documenter.getpostman.com/view/12387168/TzzDKb12</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于我的</title>
      <link href="/about.html"/>
      <url>/about.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>我的朋友</title>
      <link href="/friend.html"/>
      <url>/friend.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>下载中心</title>
      <link href="/download.html"/>
      <url>/download.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>文章归档</title>
      <link href="/archives.html"/>
      <url>/archives.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
